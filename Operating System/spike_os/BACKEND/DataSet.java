/**
 * This class represents a set of points, along with a name number of dimensions. * It also maintains a list of set names.
 */
package spike_os.BACKEND;

import java.util.ArrayList;
import java.util.List;

import javax.naming.directory.InvalidAttributesException;
public class DataSet{
/**
 * The name of this data set.
 */
protected String name, description;

/**
 * The number of dimensions in each data point in this set.
 */
protected int dimensions;

/**
 * A list of data points in this set.
 */
private List<DataPoint> dataPoints = new ArrayList<>();

/**
 * Sets the name of this data set.
 * @param newName The new name of this data set.
 */
public void setName(String newName){
    AllData.dataSets.remove(this.name, this);
    this.name = newName;
    AllData.dataSets.put(newName, this);
}

/**
 * Constructs a new DataSet object with the given name and first data point.
 * Throws an IllegalArgumentException if a data set with the same name already exists.
 * @param firstDataPoint The first data point in this set.
 * @param name The name of this data set.
 * @throws InvalidAttributesException
 */
public DataSet(){}

/**
 * Constructs a new DataSet object with the given name and first data point.
 * Throws an IllegalArgumentException if a data set with the same name already exists.
 * @param firstDataPoint The first data point in this set.
 * @param name The name of this data set.
 * @param useCase The use case for this data set.
 * @throws InvalidAttributesException
 */
public DataSet(DataPoint firstDataPoint, String name, String useCase) throws InvalidAttributesException{
   // Check if a data set with the same name already exists

   // Set the name and number of dimensions for this data set
    this.name = name;
    this.description = useCase;
    this.dimensions = firstDataPoint.dimensions;
    dataPoints.add(firstDataPoint);
    AllData.addDataSet(this, false);
}

/**
 * Constructs a new DataSet object with the given name and first data point,
 * overriding any existing data set with the same name.
 * @param firstDataPoint The first data point in this set.
 * @param name The name of this data set.
 * @param useCase The use case for this data set.
 * @throws InvalidAttributesException
 */
public static DataSet makeOverrideDataSet(DataPoint firstDataPoint, String name, String useCase) throws InvalidAttributesException{
    // Check if a data set with the same name already exists

    DataSet ds = new DataSet();
    // Set the name and number of dimensions for this data set
    ds.name = name;
    ds.description = useCase;
    ds.dimensions = firstDataPoint.dimensions;
    ds.dataPoints.add(firstDataPoint);
    AllData.addDataSet(ds, true);
    return ds;
 }

/**
 * Adds a data point to this data set.
 * Throws an InvalidAttributesException if the number of dimensions in the data point does not match
 * the number of dimensions in this data set.
 * @param toAdd The data point to add.
 * @throws InvalidAttributesException
 */
protected void addDataPoint(DataPoint toAdd) throws InvalidAttributesException{
    if(this.dimensions==toAdd.dimensions){
        dataPoints.add(toAdd);
    } else {
        throw new InvalidAttributesException("Incorrect dimensions");
    }
}

/**
 * Returns a list of the data points in this data set.
 * @return A list of the data points in this data set.
 */
protected List<DataPoint> data(){
    return dataPoints;
}

/**
 * Compiles an array of data points into a DataSet object.
 * @param data The array of data points to compile.
 * @return The compiled DataSet object.
 */
public static DataSet compileIntoDataSet(DataPoint[] data){
    DataSet output;
    try {
        output = new DataSet(data[0], "Compiled Data TEMP", "Generated by Java API");
    } catch (InvalidAttributesException e) {
        System.out.println(e.getMessage());
        try {
            output = makeOverrideDataSet(data[0], "Compiled Data TEMP", "Generated by Java API");
        } catch (InvalidAttributesException x) {
            System.out.println(x.getMessage() + ", compile failed");
            return null;
        }

    }

    for (int i=1;i<data.length;i++){
        try{
            output.addDataPoint(data[i]);
        } catch (InvalidAttributesException e){
            System.out.println("Error adding datapoint: "+e.getMessage());
        }

    }
    return output;
}

/**
 * Calculates an approximation of the area under the curve represented by this data set.
 * Uses the trapezoidal rule to approximate the area(NOT EXACT).
 * @return The approximate area under the curve.
 */
protected double approximateArea(){
    // Sort the data points in this set by the x-coordinate of each point
    sortSet(0); // Sort by the x-coordinate

    // Initialize variables for calculating the area
    double areaSum = 0, trapezoidArea;
    int n = dataPoints.size();

    // Iterate over each pair of adjacent data points in this set
    for (int i = 0; i < n-1; i++) {
        // Get the x and y coordinates of the current and next data points
        double x1 = dataPoints.get(i).cordinate[0].doubleValue();
        double y1 = dataPoints.get(i).cordinate[1].doubleValue();
        double x2 = dataPoints.get(i + 1).cordinate[0].doubleValue();
        double y2 = dataPoints.get(i + 1).cordinate[1].doubleValue();

        // Calculate the width and height of the trapezoid between the current and next data points
        double width = x2 - x1;
        double rectArea = y1*width;
        double triArea = (y2-y1)*width/2.0;

        // Calculate the area of the trapezoid and add it to the total area
        trapezoidArea = rectArea + triArea;
        areaSum += trapezoidArea;
    }

    // Return the total area
    return areaSum;
}

/**
 * Finds the mean value of the data points in this data set along the given axis.
 * @param axis The axis along which to find the mean value.
 * @return The mean value of the data points in this data set along the given axis.
 */
protected double findMeanValue(int axis){
    double sum = 0;
    int size = dataPoints.size();
    DataPoint point = new DataPoint(new Number[3]);
    for (int i = 0; i < size; i++) {
        point = dataPoints.get(i);
        sum+=point.cordinate[axis].doubleValue();
    }
    return sum/size;
}

/**
 * Sorts the data points in this set by the given index.
 * @param index The index of the coordinate to sort by.
 */
private void sortSet(int index) {
    boolean sorted = false;
    while (!sorted) {
        sorted = true; // Assume the list is sorted until a swap is made
        for (int i = 0; i < dataPoints.size() - 1; i++) {
            Number currentNumber = dataPoints.get(i).cordinate[index];
            Number nextNumber = dataPoints.get(i + 1).cordinate[index];

            // If the current data point should come after the next data point, swap them
            if (currentNumber.doubleValue() > nextNumber.doubleValue()) {
                // Swap dataPoints.get(i) with dataPoints.get(i + 1)
                DataPoint temp = dataPoints.get(i);
                dataPoints.set(i, dataPoints.get(i + 1));
                dataPoints.set(i + 1, temp);
                sorted = false; // A swap was made, so the list might not be fully sorted
            }
        }
    }
}
public DataPoint grabClosestValue(double referenceValue, int dimension){
    DataPoint minPoint = new DataPoint(new Number[3]);
    double minVal = 234987139, currentVal;
    for(int i = 0; i <dataPoints.size();i++){
        currentVal = Math.abs(dataPoints.get(i).cordinate[dimension].doubleValue()-referenceValue);
        minPoint = (currentVal<minVal)?dataPoints.get(i):minPoint;
    }
    return minPoint;
}
}